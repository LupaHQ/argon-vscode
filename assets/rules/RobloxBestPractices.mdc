---
description: 
globs: 
alwaysApply: true
---
---
description: Guidelines about Roblox scripting best-practices for client-server integrity and maintainable scripts.
globs: **/*
alwaysApply: true
---

## PRIORITY: HIGH
## READING-ORDER: 5

- In Roblox, clients (`.client.luau`) can't directly change a server-side (`.server.luau`) property - to change a server-side property, we need to request the server to do it. 
- In Roblox's security model, client scripts cannot directly modify server objects.
- For example, The `TakeDamage()` method in a client script sends that request to the server, but directly setting `Health = 0` from the client is blocked by Roblox's security system.
- Use clear variable naming (`PascalCase` for services, folders, modules, table keys and table functions;
    1. `SCREAMING_SNAKE_CASE` for constants;
    2. `camelCase` for local variables and functions).
- General script structure should go in this order: services, folders, modules, constants, and then typical variables oragnized into groups.
- Do not define Workspace as a variable, use the workspace global. Use `task.wait()`, `task.spawn()`, and `task.delay()` over `wait()`, `spawn()`, and `delay()`. 
- `task.cancel()` should be used to cancel all threads.
- Use generalized iteration (no `ipairs()` or `pairs()` is needed).
- Do not use `WaitForChild` on Workspace instances unless necessary (runtime creation or StreamingEnabled client). See UI rule below.

- **CLARIFICATION on WaitForChild for Characters:** While `WaitForChild` should be avoided for *static* items already present in the Workspace hierarchy at edit time, it is **essential** when dealing with dynamically loaded or replicated instances, particularly **player characters** on the server, especially during spawning or teleportation sequences. Always wait for the character model and necessary parts like `HumanoidRootPart` before manipulating them to avoid errors due to replication delays.
    - **EXAMPLE (Server Script - Teleporting):**
      ```luau
      local function teleportPlayerToSpawn(player: Player, position: Vector3)
          local character = player.Character or player.CharacterAdded:Wait() -- Wait for character if not present
          local hrp = character:WaitForChild("HumanoidRootPart", 5) -- Wait up to 5s for the root part
          if hrp then
              hrp.CFrame = CFrame.new(position)
          else
              warn("Could not find HumanoidRootPart for", player.Name)
          end
      end
      ```

- **WARNING: `WaitForChild` & `require()` Deadlocks:** Be cautious using `WaitForChild` in top-level code of scripts, *especially* if that script is `require`'d by another script that might be responsible for creating the instance being waited for. This can lead to deadlocks: Script A requires Script B -> Script B's top-level code runs and calls `WaitForChild("Thing")` -> Script A was supposed to create "Thing" *after* the require, but it's stuck waiting for Script B to finish loading. 
    - **SOLUTION 1:** Ensure the requiring script (Script A) finds/creates the necessary instance *before* it `require`s the dependent script (Script B).
    - **SOLUTION 2 (Lazy Loading):** Have the dependent script (Script B) look up the instance inside its functions *when they are called*, rather than at the top level. Assume the instance will exist by the time the function is used.
      ```luau
      -- Script B (ModuleScript)
      local module = {}

      -- AVOID: Top-level WaitForChild - potential deadlock if required too early
      -- local Thing = workspace:WaitForChild("Thing") 

      function module.UseThing()
          -- PREFER: Find the instance when the function is actually called
          local Thing = workspace:FindFirstChild("Thing") 
          if Thing then
              print("Found Thing:", Thing)
          else
              warn("UseThing called but Thing does not exist!")
          end
      end

      return module
      ```

- **MANAGING DEFAULT ENGINE FEATURES:** When implementing custom systems (like spawning, rounds, etc.), be mindful of default Roblox behaviors that might conflict. Disable or manage these features explicitly.
    - **EXAMPLE (Custom Spawning):** If implementing custom teleport-based spawning, disable default `SpawnLocation` objects (`spawnLocation.Enabled = false`) during periods when custom spawning is active to prevent interference.

- **MANDATORY API TYPE RULE:** Pay close attention to the expected data types for Roblox Instance properties. Assigning an incorrect Luau type (e.g., `Vector3` to a `CFrame` property) will cause runtime errors.
    - **REASON:** While Luau is dynamically typed, many Roblox properties have strict type requirements enforced by the engine.
    - **CONSEQUENCE:** Runtime errors like "Unable to assign property [PropertyName]. [ExpectedType] expected, got [ActualType]".
    - **EXAMPLE (Incorrect):**
      ```luau
      local part = Instance.new("Part")
      local positionVector = Vector3.new(0, 10, 0)
      part.CFrame = positionVector -- ERROR: Assigning Vector3 to CFrame property
      ```
    - **EXAMPLE (Correct):**
      ```luau
      local part = Instance.new("Part")
      local positionVector = Vector3.new(0, 10, 0)
      part.CFrame = CFrame.new(positionVector) -- CORRECT: Assigning a CFrame
      -- or
      part.Position = positionVector -- CORRECT: Assigning Vector3 to Position property
      ```

- **MANDATORY UI RULE:** UI elements referenced or manipulated by scripts **MUST** be created programmatically using `Instance.new()`.
    - **REASON:** Defining scripted UI via Rojo (`init.meta.json` or implicit folders) causes critical errors: type mismatches (finding `Folder` instead of `Frame`), infinite `WaitForChild` yields, timing issues (accessing properties before calculation), and conflicts with `init` scripts (e.g., `init.client.luau` expects parent to be `LocalScript`, but `init.meta.json` might force it to be `ScreenGui`, preventing the script from running correctly).
    - **CONSEQUENCE:** Non-functional UI, difficult-to-debug errors.
    - **PREFER (Correct):**
      ```luau
      -- In LocalScript:
      local frame = Instance.new("Frame")
      frame.Name = "MyFrame"
      frame.Parent = someParentScreenGui
      -- Script can now reliably use 'frame'
      ```
    - **AVOID (Incorrect):**
      ```plaintext
      # Avoid defining scripted UI via Rojo files/folders:
      # src/StarterGui/MyFrame/init.meta.json  <-- DON'T DO THIS
      # src/StarterGui/MyOtherFrame/           <-- DON'T DO THIS (creates Folder)
      ```
      ```luau
      -- Avoid finding UI defined by Rojo in scripts:
      local frame = parentGui:WaitForChild("MyFrame") -- Unreliable/Error-prone!
      ```

-- SCRIPT SECURITY CONTEXT & PROPERTY MODIFICATION --
- **SCRIPT PERMISSION LIMITATIONS:** Be aware that standard server scripts (`.server.luau`) and client scripts (`.client.luau`) run with specific, limited permissions. They cannot modify certain protected engine properties or access restricted services. Attempting to do so will result in runtime errors (e.g., "The current thread cannot write '[PropertyName]' (lacking capability Plugin)").
    - **REASON:** Security model to prevent malicious scripts from gaining excessive control.
    - **CONSEQUENCE:** Runtime errors halting script execution.
    - **EXAMPLE (Incorrect - Server Script):**
      ```luau
      -- This will likely fail in a standard Script due to permissions:
      game:GetService("Workspace").FallenPartsDestroyHeight = -10000
      game:GetService("CoreGui"):ClearAllChildren() -- Accessing/modifying CoreGui is restricted
      ```
    - **NOTE:** Modifying standard, non-protected properties of instances (like `Part.Color`, `Part.Anchored`, `Humanoid.Health` via `TakeDamage`) is generally allowed within the standard client/server security rules.

-- EVENT CONNECTION STRATEGY --
- **EVENT CONNECTION SPECIFICITY:** When detecting interactions (like touches, clicks), connect your event listener to the most specific object involved, especially if you need to know *which* object was interacted with. Avoid overly broad listeners if specific context is required.
    - **REASON:** Improves code clarity, reliability, and often performance by avoiding unnecessary checks.
    - **SCENARIO:** Making specific floor tiles disappear when a player steps on *them*.
    - **AVOID (Less Reliable/Clear):** Connecting to `Humanoid.Touched` and then trying to figure out *if* the `otherPart` was one of your specific floor tiles.
      ```luau
      -- In Player/Character Script (Less Ideal for this specific case)
      local function humanoidTouched(otherPart)
          -- Problem: Need to check if otherPart is one of the specific floor tiles.
          -- This requires searching/checking properties, less direct.
          if IsSpecificFloorTile(otherPart) and roundActive then
              MakeTileDisappear(otherPart)
          end
      end
      humanoid.Touched:Connect(humanoidTouched)
      ```
    - **PREFER (More Reliable/Clear):** Connecting directly to *each specific floor tile's* `Touched` event and checking if the toucher is a player.
      ```luau
      -- In Server Script managing the tiles
      local function handleTileTouch(otherPart, tileInstance) -- tileInstance is the specific tile
          local character = otherPart.Parent
          local humanoid = character:FindFirstChildOfClass("Humanoid")
          if humanoid and roundActive then
              -- We know 'tileInstance' is the specific tile that was touched.
              MakeTileDisappear(tileInstance)
          end
      end

      for _, tile in GetSpecificFloorTiles() do
          tile.Touched:Connect(function(partTouching)
              handleTileTouch(partTouching, tile)
          end)
      end
      ```