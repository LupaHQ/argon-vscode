---
description: 
globs: 
alwaysApply: true
---
---
description: Guidelines about Roblox scripting best-practices for client-server integrity and maintainable scripts.
globs: **/*
alwaysApply: true
---

## PRIORITY: HIGH
## READING-ORDER: 5

- In Roblox, clients (`.client.luau`) can't directly change a server-side (`.server.luau`) property - to change a server-side property, we need to request the server to do it. 
- In Roblox's security model, client scripts cannot directly modify server objects.
- For example, The `TakeDamage()` method in a client script sends that request to the server, but directly setting `Health = 0` from the client is blocked by Roblox's security system.
- Use clear variable naming (`PascalCase` for services, folders, modules, table keys and table functions;
    1. `SCREAMING_SNAKE_CASE` for constants;
    2. `camelCase` for local variables and functions).
- General script structure should go in this order: services, folders, modules, constants, and then typical variables oragnized into groups.
- Do not define Workspace as a variable, use the workspace global. Use `task.wait()`, `task.spawn()`, and `task.delay()` over `wait()`, `spawn()`, and `delay()`. 
- `task.cancel()` should be used to cancel all threads.
- Use generalized iteration (no `ipairs()` or `pairs()` is needed).
- Do not use `WaitForChild` on Workspace instances unless necessary (runtime creation or StreamingEnabled client). See UI rule below.

- **CLARIFICATION on WaitForChild for Characters:** While `WaitForChild` should be avoided for *static* items already present in the Workspace hierarchy at edit time, it is **essential** when dealing with dynamically loaded or replicated instances, particularly **player characters** on the server, especially during spawning or teleportation sequences. Always wait for the character model and necessary parts like `HumanoidRootPart` before manipulating them to avoid errors due to replication delays.
    - **EXAMPLE (Server Script - Teleporting):**
      ```luau
      local function teleportPlayerToSpawn(player: Player, position: Vector3)
          local character = player.Character or player.CharacterAdded:Wait() -- Wait for character if not present
          local hrp = character:WaitForChild("HumanoidRootPart", 5) -- Wait up to 5s for the root part
          if hrp then
              hrp.CFrame = CFrame.new(position)
          else
              warn("Could not find HumanoidRootPart for", player.Name)
          end
      end
      ```

- **CRITICAL: `WaitForChild` & `require()` Deadlocks:** Be extremely cautious using `WaitForChild` in top-level code of ModuleScripts, as this can cause deadlocks and prevent your game from loading. This issue happens in two critical scenarios:

  1. **Circular WaitForChild Dependencies:** When Module A waits for an instance that Module B is responsible for creating, but Module B also (directly or indirectly) requires Module A.
  
     - **EXAMPLE (DEADLOCK SCENARIO):**
       ```luau
       -- GameManager.luau (ModuleScript)
       local ServerStorage = game:GetService("ServerStorage")
       -- DANGEROUS: This WaitForChild blocks module execution
       local eventsFolder = ServerStorage:WaitForChild("GameEvents")
       
       local module = {}
       -- Rest of the module...
       return module
       
       -- GameInitializer.server.luau (Script)
       local GameManager = require(path.to.GameManager) -- This BLOCKS until WaitForChild completes
       
       -- Create the folder that GameManager is waiting for
       local eventsFolder = Instance.new("Folder")
       eventsFolder.Name = "GameEvents"
       eventsFolder.Parent = game:GetService("ServerStorage")
       -- This code NEVER runs because GameManager is stuck waiting!
       ```
     
     - **SOLUTION 1 (INITIALIZATION FUNCTION):**
       ```luau
       -- GameManager.luau (ModuleScript)
       local ServerStorage = game:GetService("ServerStorage")
       
       local module = {}
       
       function module.Initialize()
           -- Move WaitForChild inside a function that's called AFTER all instances are created
           local eventsFolder = ServerStorage:WaitForChild("GameEvents")
           -- Setup that requires the events folder...
       end
       
       return module
       
       -- GameInitializer.server.luau (Script)
       local GameManager = require(path.to.GameManager) -- This returns immediately
       
       -- Create the folder
       local eventsFolder = Instance.new("Folder")
       eventsFolder.Name = "GameEvents"
       eventsFolder.Parent = game:GetService("ServerStorage")
       
       -- NOW it's safe to initialize
       GameManager.Initialize()
       ```
     
     - **SOLUTION 2 (FindFirstChild WITH RETRY):**
       ```luau
       -- GameManager.luau (ModuleScript)
       local ServerStorage = game:GetService("ServerStorage")
       
       local module = {}
       
       -- Check non-blocking for resources
       local function getEventsFolder()
           local folder = ServerStorage:FindFirstChild("GameEvents")
           if not folder then
               warn("GameEvents folder not found yet")
               return nil
           end
           return folder
       end
       
       function module.DoSomething()
           local eventsFolder = getEventsFolder()
           if not eventsFolder then
               -- Handle missing folder case or retry logic
               return
           end
           -- Use the folder...
       end
       
       return module
       ```

  2. **Game Services and Dependencies:** When modules wait for instances that might not exist until later in the game lifecycle.
  
     - **EXAMPLE (DANGEROUS):**
       ```luau
       -- MapManager.luau (ModuleScript)
       local ReplicatedStorage = game:GetService("ReplicatedStorage")
       
       -- DANGEROUS: Top-level WaitForChild can deadlock if required during game start
       local remoteEvent = ReplicatedStorage:WaitForChild("RoundStateChanged") 
       
       local module = {}
       -- Rest of module...
       return module
       ```
     
     - **SOLUTION (LAZY LOADING):**
       ```luau
       -- MapManager.luau (ModuleScript)
       local ReplicatedStorage = game:GetService("ReplicatedStorage")
       
       local module = {}
       
       -- Private helper that gets called only when needed
       local function getRemoteEvent()
           -- Find first, and only wait if needed at usage time
           local event = ReplicatedStorage:FindFirstChild("RoundStateChanged")
           if not event then
               warn("Remote event not found, will wait")
               event = ReplicatedStorage:WaitForChild("RoundStateChanged", 10)
           end
           return event
       end
       
       function module.NotifyClients(state)
           local remoteEvent = getRemoteEvent()
           if remoteEvent then
               remoteEvent:FireAllClients(state)
           end
       end
       
       return module
       ```

- **MANAGING DEFAULT ENGINE FEATURES:** When implementing custom systems (like spawning, rounds, etc.), be mindful of default Roblox behaviors that might conflict. Disable or manage these features explicitly.
    - **EXAMPLE (Custom Spawning):** If implementing custom teleport-based spawning, disable default `SpawnLocation` objects (`spawnLocation.Enabled = false`) during periods when custom spawning is active to prevent interference.

- **MANDATORY API TYPE RULE:** Pay close attention to the expected data types for Roblox Instance properties. Assigning an incorrect Luau type (e.g., `Vector3` to a `CFrame` property) will cause runtime errors.
    - **REASON:** While Luau is dynamically typed, many Roblox properties have strict type requirements enforced by the engine.
    - **CONSEQUENCE:** Runtime errors like "Unable to assign property [PropertyName]. [ExpectedType] expected, got [ActualType]".
    - **EXAMPLE (Incorrect):**
      ```luau
      local part = Instance.new("Part")
      local positionVector = Vector3.new(0, 10, 0)
      part.CFrame = positionVector -- ERROR: Assigning Vector3 to CFrame property
      ```
    - **EXAMPLE (Correct):**
      ```luau
      local part = Instance.new("Part")
      local positionVector = Vector3.new(0, 10, 0)
      part.CFrame = CFrame.new(positionVector) -- CORRECT: Assigning a CFrame
      -- or
      part.Position = positionVector -- CORRECT: Assigning Vector3 to Position property
      ```

- **MANDATORY UI RULE:** UI elements referenced or manipulated by scripts **MUST** be created programmatically using `Instance.new()`.
    - **REASON:** Defining scripted UI via Rojo (`init.meta.json` or implicit folders) causes critical errors: type mismatches (finding `Folder` instead of `Frame`), infinite `WaitForChild` yields, timing issues (accessing properties before calculation), and conflicts with `init` scripts (e.g., `init.client.luau` expects parent to be `LocalScript`, but `init.meta.json` might force it to be `ScreenGui`, preventing the script from running correctly).
    - **CONSEQUENCE:** Non-functional UI, difficult-to-debug errors.
    - **PREFER (Correct):**
      ```luau
      -- In LocalScript:
      local frame = Instance.new("Frame")
      frame.Name = "MyFrame"
      frame.Parent = someParentScreenGui
      -- Script can now reliably use 'frame'
      ```
    - **AVOID (Incorrect):**
      ```plaintext
      # Avoid defining scripted UI via Rojo files/folders:
      # src/StarterGui/MyFrame/init.meta.json  <-- DON'T DO THIS
      # src/StarterGui/MyOtherFrame/           <-- DON'T DO THIS (creates Folder)
      ```
      ```luau
      -- Avoid finding UI defined by Rojo in scripts:
      local frame = parentGui:WaitForChild("MyFrame") -- Unreliable/Error-prone!
      ```

-- SCRIPT SECURITY CONTEXT & PROPERTY MODIFICATION --
- **SCRIPT PERMISSION LIMITATIONS:** Be aware that standard server scripts (`.server.luau`) and client scripts (`.client.luau`) run with specific, limited permissions. They cannot modify certain protected engine properties or access restricted services. Attempting to do so will result in runtime errors (e.g., "The current thread cannot write '[PropertyName]' (lacking capability Plugin)").
    - **REASON:** Security model to prevent malicious scripts from gaining excessive control.
    - **CONSEQUENCE:** Runtime errors halting script execution.
    - **EXAMPLE (Incorrect - Server Script):**
      ```luau
      -- This will likely fail in a standard Script due to permissions:
      game:GetService("Workspace").FallenPartsDestroyHeight = -10000
      game:GetService("CoreGui"):ClearAllChildren() -- Accessing/modifying CoreGui is restricted
      ```
    - **NOTE:** Modifying standard, non-protected properties of instances (like `Part.Color`, `Part.Anchored`, `Humanoid.Health` via `TakeDamage`) is generally allowed within the standard client/server security rules.

-- EVENT CONNECTION STRATEGY --
- **EVENT CONNECTION SPECIFICITY:** When detecting interactions (like touches, clicks), connect your event listener to the most specific object involved, especially if you need to know *which* object was interacted with. Avoid overly broad listeners if specific context is required.
    - **REASON:** Improves code clarity, reliability, and often performance by avoiding unnecessary checks.
    - **SCENARIO:** Making specific floor tiles disappear when a player steps on *them*.
    - **AVOID (Less Reliable/Clear):** Connecting to `Humanoid.Touched` and then trying to figure out *if* the `otherPart` was one of your specific floor tiles.
      ```luau
      -- In Player/Character Script (Less Ideal for this specific case)
      local function humanoidTouched(otherPart)
          -- Problem: Need to check if otherPart is one of the specific floor tiles.
          -- This requires searching/checking properties, less direct.
          if IsSpecificFloorTile(otherPart) and roundActive then
              MakeTileDisappear(otherPart)
          end
      end
      humanoid.Touched:Connect(humanoidTouched)
      ```
    - **PREFER (More Reliable/Clear):** Connecting directly to *each specific floor tile's* `Touched` event and checking if the toucher is a player.
      ```luau
      -- In Server Script managing the tiles
      local function handleTileTouch(otherPart, tileInstance) -- tileInstance is the specific tile
          local character = otherPart.Parent
          local humanoid = character:FindFirstChildOfClass("Humanoid")
          if humanoid and roundActive then
              -- We know 'tileInstance' is the specific tile that was touched.
              MakeTileDisappear(tileInstance)
          end
      end

      for _, tile in GetSpecificFloorTiles() do
          tile.Touched:Connect(function(partTouching)
              handleTileTouch(partTouching, tile)
          end)
      end
      ```

-- COMMUNICATION: Remote vs. Bindable --
- **RULE:** Choose the correct communication object based on the direction of communication:
    - **`RemoteEvent` / `RemoteFunction`:** Use **ONLY** for communication **between Client and Server** (in either direction). These involve network replication.
        - Server -> Client(s): `RemoteEvent:FireClient(player, ...)`, `RemoteEvent:FireAllClients(...)`
        - Client -> Server: `RemoteEvent:FireServer(...)`, `RemoteFunction:InvokeServer(...)`
        - Server -> Client (Function): `RemoteFunction:InvokeClient(player, ...)` (Use with caution, client might not respond)
    - **`BindableEvent` / `BindableFunction`:** Use for communication **within the same context**: Server <-> Server **OR** Client <-> Client. These do **NOT** involve the network.
        - Event Trigger: `BindableEvent:Fire(...)`
        - Function Call: `BindableFunction:Invoke(...)`

- **WARNING:** Using `RemoteEvent`/`RemoteFunction` for server-to-server or client-to-client communication is incorrect, inefficient, and will lead to errors because the firing/invoking methods differ.

- **EXAMPLE (Server-to-Server Communication):**
    ```luau
    -- INCORRECT: Using RemoteEvent between two server scripts
    -- Script A (Server)
    local myRemoteEvent = Instance.new("RemoteEvent", game.ReplicatedStorage)
    myRemoteEvent:Fire("Data") -- ERROR: :Fire() is not the correct method here

    -- Script B (Server)
    local myRemoteEvent = game.ReplicatedStorage:WaitForChild("MyRemoteEvent")
    myRemoteEvent.OnServerEvent:Connect(function(data) print(data) end) -- This listener won't fire correctly from server :Fire()
    ```
    ```luau
    -- CORRECT: Using BindableEvent between two server scripts
    -- Script A (Server)
    local myBindableEvent = Instance.new("BindableEvent", game.ReplicatedStorage) -- Or ServerStorage
    myBindableEvent:Fire("Data") -- CORRECT: Use :Fire()

    -- Script B (Server)
    local myBindableEvent = game.ReplicatedStorage:WaitForChild("MyBindableEvent")
    myBindableEvent.Event:Connect(function(data) print(data) end) -- CORRECT: Use .Event
    ```